#+title: guix-config

* Introduction

These are my [[https://guix.gnu.org][GNU Guix]] configuration files.

This config extends Guix with a custom data type (dubbed "mods") to modularize
my setup.  It also includes some additional packages and services that are
either being refined for upstreaming or are not suitable for upstream.

* Overview

Here is a general overview of notable files in this repository:

- [[file:files]] contains configuration files that are not declared in Guile
  modules.
- [[file:modules]] contains Guile modules, where packages, services, and other
  utilities are defined.  =GUIX_PACKAGE_PATH= is set to this directory.
- [[file:systems]] and [[file:modules/my-guix/systems]] are where the top-level Guix
  System/Home configuration files for my systems are located.
- [[file:scripts/setup]] is used for setting up additional things that the installer
  does not offer to do.
- [[file:scripts/guix]] is used for bootstrapping the configuration when
  =GUIX_PACKAGE_PATH= is not set yet.


The following sections include documentation for various services and interfaces
provided by the Guile modules.

* Mods

This configuration utilizes "mods", an extension to Guix records that can be
used to modularize configurations; in this case, particularly ~operating-system~
and ~home-environment~ records.

The basic idea is that most configurations can be broken down into parts that
extend the environment, like adding to the list of packages or kernel arguments.
Mods provide a way to capture these types of configurations into logical groups
that make them easier to remove, include, and manage in environments, especially
when maintaining multiple systems that share only a subset of configurations.

For instance, the ~file-system-management-mod~ in this repository is defined
like so:
#+begin_src scheme
  (define file-system-management-mod
    (operating-system-mod
      (name 'file-system-management)
      (description
       "Provides software to support various file system operations and disk
  management/maintenance.")
      (packages (let-mod-arguments (this-operating-system-mod-arguments)
                    ((replace-mesa replace-mesa-argument))
                  (list btrfs-progs
                        cryptsetup
                        (replace-mesa gnome-disk-utility)
                        gparted
                        gptfdisk
                        lvm2
                        ntfs-3g)))
      (services (list (service fstrim-service-type)))))
#+end_src
(From [[file:modules/my-guix/mods/base.scm]].)

To apply mods, users must specify a ~modded-configuration~ record where mods and
the base record can be declared.  From there, the final configuration can be
built with a corresponding procedure; e.g.,
~modded-configuration-operating-system~.  This produces top-level configurations
that might look something like the following:

#+begin_src scheme
  ;; Machine-specific configurations can still be included here.
  (define base-operating-system
    (operating-system
      ...))

  (define modded-operating-system
    (modded-configuration
      ...
      (base base-operating-system)
      ;; meta-desktop-mod includes file-system-management-mod.
      (mods (list meta-desktop-mod
                  meta-entertainment-mod
                  gnome-mod
                  nvidia-mod
                  ssh-server-mod))))

  ...

  ;; Return an operating-system record for guix system reconfigure.
  (modded-configuration-operating-system modded-operating-system)
#+end_src
(From [[file:modules/my-guix/systems/al-pc.scm]] and [[file:systems/al-pc.scm]].)

Specifications for the relevant facilities are documented below.

The ~(my-guix mods)~ module provides abstractions for implementing mods and
defining top-level configurations.

- Data Type: modded-configuration ::
  Fields:
  - =arguments= :: List of keyword arguments that can be used by mods.

    See [[id:04a22196-4b5a-4e62-9bec-485a90c0d681][Mod Arguments]] for documentation on using mod arguments.
  - =base= :: The base record that mods will be applied to.
  - =mods= :: List of mods to apply.


On its own, ~modded-configuration~ cannot do anything - it still needs a
corresponding implementation and conversion procedure for the record type that
the user intends to extend.  In the case of ~operating-system~, an
implementation is provided in the ~(my-guix mods)~ module, documented below.

- Data Type: operating-system-mod :: Mod for ~operating-system~ records.

  Fields:
  - =name= :: The name of the mod, for debugging purposes.
  - =description= :: A description of what the mod does when applied.
  - =arguments= :: Arguments supplied by ~modded-configuration~.

    This is an internal field that is managed by
    ~modded-configuration-operating-system~, and is normally accessed by
    ~(this-operating-system-mod-arguments)~.
  - =addons= :: List of additional mods to apply when this mod is applied.
  - =kernel-arguments= :: List of additional kernel arguments for the operating
    system.
  - =swap-devices= :: List of additional swap devices for the operating system.
  - =packages= :: List of additional packages for the operating system.
  - =services= :: List of additional services for the operating system.
  - =modifier= :: Procedure that takes an ~operating-system~ and returns a
    modified ~operating-system~.

    This field is applied after all other fields in all other mods are applied.
    It is an escape hatch intended for non-extensible cases, and should be used
    sparingly.
- Special Form: (this-operating-system-mod-arguments) :: Returns the contextual
  mod's arguments as passed from ~modded-configuration~.
- Function: modded-configuration-operating-system config :: Apply mods from a
  ~modded-configuration~ CONFIG to its base configuration, and return the
  resulting ~operating-system~.

An implementation for ~home-environment~ mods is also provided under the
~(my-guix home mods)~ module.

- Data Type: home-environment-mod :: Mod for ~home-environment~ records.

  Since ~home-environment~ fields are practically a subset of ~operating-system~
  fields, all fields listed below correspond to those documented for
  ~operating-system-mod~; see its documentation for information on respective
  entries.

  Fields:
  - =name= ::
  - =description= ::
  - =arguments= ::
  - =addons= ::
  - =packages= ::
  - =services= ::
  - =modifier= ::
- Special Form: (this-home-environment-mod-arguments) :: Returns the contextual
  mod's arguments as passed from ~modded-configuration~.
- Function: modded-configuration-home-environment config :: Apply mods from a
  ~modded-configuration~ CONFIG to its base configuration, and return the
  resulting ~home-environment~.

** Mod arguments
:PROPERTIES:
:ID:       04a22196-4b5a-4e62-9bec-485a90c0d681
:END:

Readers may notice bits related to "arguments" that were mentioned in the
previous section.  These are facilities that enable mods to be parameterized -
akin to Guile's parameters - using values that are specified in the top-level
~modded-configuration~.

For example, let's say a user would like to configure a swapfile.  After
creating one, normally they would include something like the following in
their configuration to begin using it:

#+begin_src scheme
  (operating-system
    [...]
    (swap-devices
     (list (swap-space
             (target "/swapfile")
             (dependencies
              (filter (file-system-mount-point-predicate "/") file-systems)))))
    (kernel-arguments
     (list "resume=/dev/mapper/cryptroot"
           "resume_offset=6036736")))
#+end_src

It would be easy to directly convert this into a mod, but - ideally - mods
should be usable by other systems, as well; the swapfile path, device, and
offset will not necessarily be the same per system.  To account for this, the
~modded-configuration~ record accepts an =arguments= field, which is a list of
keyword arguments that are made accessible to mods during evaluation, e.g. via
~(this-operating-system-mod-arguments)~.  This value can be used by mods to
allow variations in configurations, without having to essentially duplicate mods
for each system.

"Mod arguments" are facilities that build on top of this feature to make it
easier to define and access arguments, and are described below.

For example, the following defines a swapfile mod argument which is used in the
swapfile mod:

#+begin_src scheme
  (define-configuration/no-serialization swapfile-configuration
    (file string "Path to swapfile.")
    (device string "Device that swapfile is present on.")
    (offset string "Offset of swapfile."))

  (define swapfile-argument
    (mod-argument
      (keyword #:swapfile)
      ;; Don't set a default value; the user must specify a
      ;; swapfile-configuration in arguments if they include the swapfile mod.
      (description "Swapfile configuration.")))

  (define swapfile-mod
    (operating-system-mod
      (name 'swapfile)
      (description
       "Configures swapfile for the system.  See <info:guix#Swap Space> for more
  information.  If the setup script in this repository is used to set up the
  swapfile, it should output all the swapfile configuration information needed.

  The base operating system must include the swapfile file system
  configuration.")
      (swap-devices
       (let-mod-arguments (this-operating-system-mod-arguments)
           ;; base-configuration-argument is provided by (my-guix mods).
           ((base-configuration base-configuration-argument)
            (swapfile swapfile-argument))
         (match-record swapfile <swapfile-configuration> (file)
           (list (swap-space
                   (target file)
                   (dependencies
                    (filter (file-system-mount-point-predicate "/")
                            (operating-system-file-systems base-configuration))))))))
      (kernel-arguments
       (let-mod-arguments (this-operating-system-mod-arguments)
           ((swapfile swapfile-argument))
         (match-record swapfile <swapfile-configuration> (device offset)
           (list (string-append "resume=" device)
                 (string-append "resume_offset=" offset)))))))
#+end_src
(From [[file:modules/my-guix/mods/base.scm]].)

For convenience, due to the swapfile having multiple variables - i.e., the file,
device, and offset - we start by collecting them into a configuration record
type that will be expected as the argument.

The ~mod-argument~ record type is used to define mod arguments.  In the case of
~swapfile-argument~, the ~#:swapfile~ keyword will be used to specify its value.
It is also a required argument, since the =default-value= field is not set.  The
description is another optional field for documenting the argument's purpose.

This defined mod argument is then specified in ~let-mod-arguments~, which will
use its information to acquire the argument's value from
~(this-operating-system-mod-arguments)~ and let-bind it to the symbol ~swapfile~
(or raise an exception, if it isn't found).

Finally, the system-dependent argument value can be specified in
~modded-configuration~.  The full ~modded-configuration~ from
[[file:modules/my-guix/systems/al-pc.scm]] looks like so:

#+begin_src scheme
  (define modded-operating-system
    (modded-configuration
      (arguments (list
                  #:swapfile (swapfile-configuration
                              (file "/swapfile")
                              (device "/dev/mapper/cryptroot")
                              (offset "6036736"))))
      (base base-operating-system)
      (mods (list meta-desktop-mod
                  meta-entertainment-mod
                  gnome-mod
                  nvidia-mod
                  ssh-server-mod))))
#+end_src

~(my-guix mods)~ provides the various facilities for using mod arguments,
documented below.

- Data Type: mod-argument :: A mod argument.

  Fields:
  - =keyword= :: The keyword used to specify the argument value.
  - =default-value= :: Value used as a fallback, if no corresponding keyword
    argument can be found.

    When there is no default, an exception will be raised.
  - =sanitizer= :: Procedure that the argument value is passed to before
    let-binding it in ~let-mod-arguments~.
- Macro: let-mod-arguments arguments bindings body ... :: Let-bind keyword
  argument values from ARGUMENTS, and execute BODY in that context.

  This form is similar to ~let-keywords~ from ~(ice-9 optargs)~, with the
  notable difference being that default values are replaced with ~mod-argument~
  records, taking the following form in BINDINGS:
  #+begin_src lisp-data
    ((VARIABLE MOD-ARG) ...)
  #+end_src
  where MOD-ARG is a ~mod-argument~ record.  These records are then used by
  ~let-mod-arguments~ to determine and set values based on ARGUMENTS.
- Variable: base-configuration-argument :: The base configuration record that
  was specified in ~modded-configuration~.

  This is set to the base record by default.  It is technically possible to
  override this value with the =#:base-configuration= keyword, but generally
  this is only meant to be consumed by mods.
- Variable: ignored-mods-argument :: A list of mods that should never be
  applied.

  By default, this is an empty list.  This is specified with the
  =#:ignored-mods= keyword.

* Services

** Hardware Services

The ~(my-guix services hardware)~ module provides services relating to
hardware.

*** ~keyboard-center-service-type~

This service adds udev rules necessary for the =keyboard-center= package to
work.

No configuration is available for this service, so the following should
suffice:

#+begin_src scheme
  (service keyboard-center-service-type)
#+end_src

* Home Services

The following sections document custom services used in home configurations.

** Package Management

The ~(my-guix home services package-management)~ module provides additional
services for package management.

*** ~home-flatpak-service-type~

This is the service type for configuring Flatpak. It expects a
~home-flatpak-configuration~ record as its value.

Only installation of flatpaks is supported to avoid accidental removals that
cause reinstallations. Although this service (mostly) works in its current
form, the interface is still experimental and will likely go through changes
to improve flexibility and capabilities.

To start using this service, it must be configured with at least one
remote. The following example configures Flatpak to use Flathub as a remote:

#+begin_src scheme
  (service home-flatpak-service-type
           (home-flatpak-configuration
            (remotes
             '(("flathub" "https://flathub.org/repo/flathub.flatpakrepo")))))
#+end_src

~home-flatpak-service-type~ may itself be extended to add applications to the
profile, but it can be fairly cumbersome having to specify
~home-flatpak-configuration~ every time. ~home-flatpak-profile-service-type~
is included as a shorthand service for specifying lists of application
specifications to include in the profile, that being ~(remote app-id)~. The
following declares the Firefox and Brave Browser flatpaks in the home
environment (assuming that Flathub is already configured as shown above):

#+begin_src scheme
  (simple-service 'home-flatpak-browsers
                  home-flatpak-profile-service-type
                  '(("flathub" "org.mozilla.firefox")
                    ("flathub" "com.brave.Browser")))
#+end_src

Note that on foreign systems, the Guix Flatpak package will fail to properly
run if CA certificates cannot be found, which can be a problem for first-time
reconfigures where certificates for Guix have not been set up yet (notably
=SSL_CERT_FILE=).  However, as long as the relevant variable and package(s)
are specified in the configuration, they will still be applied even if Flatpak
fails to run, so subsequent reconfigures should work as intended after
reloading the environment.

Guix System users should not have this problem since certificates should
already be properly set up by the time a home reconfigure takes place.
